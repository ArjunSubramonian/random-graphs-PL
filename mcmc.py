# -*- coding: utf-8 -*-
"""mcmc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GM46arsndPuJeVyBhkphuYlVDydL2A0b
"""

import torch

N = 1000
p = 0.01
L = int(p * N * N)

from torch.distributions.categorical import Categorical
m = Categorical(torch.ones(N) / N)

perm = torch.randperm(N * N)
idx = perm[:L // 2]
edge_index = torch.zeros((2, L)).long()
for pos, i in enumerate(idx):
    u = i // N
    v = i % N
    edge_index[0, 2 * pos] = u
    edge_index[1, 2 * pos] = v
    edge_index[0, 2 * pos + 1] = v
    edge_index[1, 2 * pos + 1] = u

from torch_geometric.utils import coalesce, remove_self_loops
edge_index = coalesce(edge_index)
edge_index, _ = remove_self_loops(edge_index)
print(edge_index.size())

from torch_geometric.utils import is_undirected
is_undirected(edge_index)

# from torch_geometric.utils import to_undirected
# A_flat = torch.zeros((N * N,))
# A_flat[idx] = 1
# edge_index_test = to_undirected(A_flat.reshape(N, N).nonzero().t(), num_nodes=N)
# print(edge_index_test.size())
# (edge_index == edge_index_test).all()

from torch_geometric.utils import degree
deg = degree(edge_index[0])

sigma = (deg ** 2).sum().item()
print(sigma)

running_num_triangles = 0

from torch_geometric.utils import to_torch_coo_tensor, to_dense_adj

def count_triangles(edge_index):
    sp_edge_index = to_torch_coo_tensor(edge_index)
    mp = torch.sparse.mm(torch.sparse.mm(sp_edge_index, sp_edge_index), sp_edge_index)
    idx = mp.indices()
    vals = mp.values()

    # A = to_dense_adj(edge_index)[0]
    # print(torch.trace(A @ A @ A))
    
    mask = idx[0] == idx[1]
    return vals[mask].sum() / 6

num_triangles = count_triangles(edge_index)
true_count = num_triangles
delta_ij = 0
delta_ik = 0

ei = edge_index.clone()

# running_num_triangles = 0
running_num_triangles_test = 0

for t in range(1, 1001):

    # running_num_triangles += (true_count - running_num_triangles) / t
    running_num_triangles_test += (num_triangles - running_num_triangles_test) / t
    if t % 100 == 0:
        # print(running_num_triangles)
        print(running_num_triangles_test)

    while True:
        i, j = ei[:, torch.randint(ei.size(1), (1,))[0]]
        i = i.item()
        j = j.item()
        assert ((ei[0] == j) & (ei[1] == i)).any()
        
        node_dist = torch.ones(N)
        node_dist[i] = 0
        node_dist[j] = 0
        k = node_dist.multinomial(1)[0]
        k = k.item()

        if (k != ei[1, ei[0] == i]).all():
            break

    sigma_prime = (sigma + 2 * (1 + deg[k] - deg[j])).item()
    p_execute_move = ((N - 1) * L - sigma) * torch.exp(m.log_prob(deg[j] - 1)) * torch.exp(m.log_prob(deg[k] + 1)) * (deg[k] + 1)
    p_execute_move /= ((N - 1) * L - sigma_prime) * torch.exp(m.log_prob(deg[j])) * torch.exp(m.log_prob(deg[k])) * deg[j]
    r = torch.rand(1)[0].item()
    if r < p_execute_move.item():
        pos_1 = (ei[0] == i) & (ei[1] == j)
        # print(i, j, ei[:, pos_1])

        pos_2 = (ei[0] == j) & (ei[1] == i)
        # print(i, j, ei[:, pos_2])

        adj_i_1 = ei[1, ei[0] == i]
        adj_j = ei[1, ei[0] == j]

        ei[1, pos_1] = k
        # print(i, k, ei[:, pos_1])

        ei[0, pos_2] = k
        # print(k, i, ei[:, pos_2])

        sigma = sigma_prime

        deg[k] += 1
        deg[j] -= 1

        adj_i_2 = ei[1, ei[0] == i]
        adj_k = ei[1, ei[0] == k]

        delta_ij = -(adj_i_1.reshape(-1, 1) == adj_j).sum()
        delta_ik = (adj_i_2.reshape(-1, 1) == adj_k).sum()
        num_triangles += delta_ik + delta_ij

        # assert i != j
        # assert j != i
        # assert j != k
        # assert k != i

        # prev_count = true_count
        # true_count = count_triangles(ei)
        # if true_count - prev_count != delta_ij + delta_ik:
        #     print(prev_count, true_count, delta_ij, delta_ik)
        #     print(i, j, k)
        #     print(adj_i_1, adj_j)
        #     print(adj_i_2, adj_k)
        #     print()

running_num_triangles_test

import math
N = 1000
p = 0.25
L = int(p * N * N)
lam = L / (N * (N - 1) / 2 - L)
A = torch.zeros((N, N)).long()

for t in range(1, 1001):
    i, j = torch.randperm(N)[:2]
    if A[i, j] == 0:
        prob_execute_move = min(1, lam)
    else:
        prob_execute_move = min(1, 1 / lam)
    
    r = torch.rand(1)[0].item()
    if r < prob_execute_move:
        A[i, j] = 1 - A[i, j]
        A[j, i] = 1 - A[j, i]

A.sum()

