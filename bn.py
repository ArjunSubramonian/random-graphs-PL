# -*- coding: utf-8 -*-
"""ABI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-e-jsJ1EkuhBeAiaMqvnOI9m7BnNWIBO
"""

# !pip install pgmpy

from pgmpy.models import BayesianNetwork
from pgmpy.factors.discrete import TabularCPD
from pgmpy.inference import VariableElimination
from pgmpy.inference import ApproxInference
import itertools
import numpy as np

import time
import signal

import sys


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


class TimeoutException(Exception):  # Custom exception class
    pass


def timeout_handler(signum, frame):  # Custom signal handler
    raise TimeoutException


# Change the behavior of SIGALRM
signal.signal(signal.SIGALRM, timeout_handler)

print("[")
for num_nodes_step in range(1, 7):
    num_nodes = 2**num_nodes_step
    eprint("num nodes = {}".format(num_nodes))

    times = []
    for p_step in range(1, 6):
        p = 0.2 * p_step
        for q_step in range(1, 6):
            q = 0.2 * q_step
            eprint("p = {}".format(p), "q = {}".format(q))

            signal.alarm(60)  # time out after a minute
            start_time = time.time()

            try:
                edges = []
                cpds = {}
                for subset in itertools.combinations(list(range(num_nodes)), 3):
                    n1, n2, n3 = subset
                    tri_node = str(n1) + "_" + str(n2) + "_" + str(n3)

                    evidence = []
                    for u1, u2 in itertools.combinations(subset, 2):
                        edge_node = str(u1) + "_" + str(u2)

                        if u1 < num_nodes // 2 and u2 < num_nodes // 2:
                            prob = p
                        elif u1 >= num_nodes // 2 and u2 >= num_nodes // 2:
                            prob = p
                        else:
                            prob = q

                        cpds[edge_node] = TabularCPD(
                            variable=edge_node,
                            variable_card=2,
                            values=[[1 - prob], [prob]],
                        )
                        evidence.append(edge_node)

                    cpds[tri_node] = TabularCPD(
                        variable=tri_node,
                        variable_card=2,
                        values=[
                            [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0],
                        ],
                        evidence=evidence,
                        evidence_card=[2, 2, 2],
                    )

                    for edge_node in evidence:
                        edges.append((edge_node, tri_node))

                graph_model = BayesianNetwork(edges)
                graph_model.add_cpds(*list(cpds.values()))
                # eprint(graph_model.check_model())

                graph_infer = VariableElimination(graph_model)

                vars = []
                expected_triangles = 0
                for subset in itertools.combinations(list(range(num_nodes)), 3):
                    n1, n2, n3 = subset
                    tri_node = str(n1) + "_" + str(n2) + "_" + str(n3)
                    vars.append(tri_node)

                    evidence = {
                        # "0_1": 1
                    }
                    if tri_node not in evidence:
                        q = graph_infer.query(variables=[tri_node], evidence=evidence)
                        # expected_triangles += q.values[1]
                    else:
                        # expected_triangles += 1
                        pass
                # eprint(expected_triangles)

                # graph_model.local_independencies("0_1_2")
                # len(list(itertools.combinations(list(range(num_nodes)), 3)))
                # infer = ApproxInference(graph_model)
                # infer.query(variables=vars, joint=False)
            except TimeoutException:
                eprint("Took too long!")
                pass
            else:
                # Reset the alarm
                signal.alarm(0)

            time_elapsed = time.time() - start_time
            times.append(time_elapsed)

    eprint()
    eprint(
        "time taken:",
        str(np.mean(np.array(times))) + " Â± " + str(np.std(np.array(times))),
    )
    eprint()

    print(
        f'{{  "n": {num_nodes}, "mean": {str(np.mean(np.array(times)))}, "std": {str(np.std(np.array(times)))}, "times": {times} }},'
    )

print("]")
